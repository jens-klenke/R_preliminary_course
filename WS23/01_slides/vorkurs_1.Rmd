---
title: "R-Vorkurs WS 23/24"
subtitle: "Teil 1"
author: 
  - "Jens Klenke"
date: "XX.10.2023"
output:
  xaringan::moon_reader:
    css: ["default", "assets/ude-fonts.css", "assets/ude.css"]
    self_contained: true # if true, fonts will be stored locally
    seal: true # show a title slide with YAML information
    includes:
      in_header: "assets/mathjax-equation-numbers.html"
    nature:
      beforeInit: ["assets/remark-zoom.js", "https://platform.twitter.com/widgets.js"]
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: '16:9' #alternatives '16:9' or '4:3' or others e.g. 13:9
      navigation:
        scroll: true #disable slide transitions by scrolling
---

```{r xaringanExtra-clipboard_2, echo=FALSE}
# copy button styles mainly in ude.css 
# https://github.com/gadenbuie/xaringanExtra
htmltools::tagList(
  xaringanExtra::use_clipboard(
    button_text = "<i class=\"fa fa-clipboard\"></i>",
    success_text = "<i class=\"fa fa-check\" style=\"color: #00ff00\"></i>",
    error_text = "<i class=\"fa fa-times-circle\" style=\"color: #F94144\"></i>"
  ),
  rmarkdown::html_dependency_font_awesome()
)
```

```{r setup, include=FALSE}
options(repos = list(CRAN = "http://cran.rstudio.com/"))
options(htmltools.dir.version = FALSE)
options(servr.daemon = TRUE)
options(servr.interval = 0.5)

#xaringan::inf_mr()

#### required packages ####
# packages
suppressWarnings(source(here::here('00_packages/packages.R')))

r_white <- icon_style(fontawesome$brands$'r-project', fill = "white")
r_black <- icon_style(fontawesome$brands$'r-project', fill = "black")
r_blue <- icon_style(fontawesome$brands$'r-project', fill = "#004c93")
smiley <- icon_style(fontawesome("smile", style = "solid"), scale = 2, fill = "#004c93")
grin_wink <- icon_style(fontawesome("grin-wink", style = "solid"), scale = 2, fill = "#004c93")
```


## Übersicht 

<br> 
1. `r r_black` und *RStudio*
1. Grundlagen 
1. Vektoren
1. Matrizen

---
## `r r_blue` und *RStudio*

<br>
`r r_black` ist eine freie Programmiersprache für statistische Berechnungen/Grafiken und wurde von Statistikern für Anwender mit statistischen Aufgaben entwickelt.

--
<br>

### Was ist *RStudio*? Brauche ich das?

- *RStudio* ist eine integrierte Entwicklungsumgebung und grafische Benutzeroberfläche für `r r_black`.
- *RStudio* bietet eine Menge an Komfortfunktionen, die das Arbeiten mit `r r_black` vereinfachen.  

--

<br>

$\Rightarrow$ **Wir arbeiten daher mit RStudio**

--

<br>
**Wichtig: *RStudio* ist nicht gleich `r r_black`! Ohne eine `r r_black`-Installation bringt *RStudio* nichts.** 
---
## Grundlagen
  
### Grundrechenarten

`r r_black` kann als einfacher Taschenrechner benutzt werden. 

```{r, results='hold'}
5 + 7
2 - 8
12 * 12
8 / 3
```

---
## Grundlagen
### ... und mehr 

```{r, results='hold'}
# "12 hoch 2"
12^2

# Logarithmus von 144 zur Basis 12
log(144, base = 12)

# "e hoch 3"
exp(3)

# "Logarithmus von e hoch 3"
log(exp(3))

# "Sinus von 2 Pi"
sin(2 * pi)
```

---
## Grundlagen
### Wissenschaftliche Notation

</br>

`r r_black` stellt besonders große bzw. besonders kleine Zahlen mit Hilfe der [wissenschaftlichen Notation](https://de.wikipedia.org/wiki/Wissenschaftliche_Notation) dar. 

--

Die Zahl -2.449294e-16 aus dem `r r_black`-Output ist

<br>
</br>

$$-2.449294 \times 10^{-16} = \dfrac{-2.449294}{10 \; 000 \;000 \; 000 \; 000 \;000} \approx 0.$$

<br>
</br>

--
- Auf den zweiten Blick ist die wissenschaftliche Notation also tatsächlich nutzerfreundlicher.

---
## Grundlagen
### Variablen 

</br>

Variablen werden mit dem Zuweisungsoperator `<-` ("Kleinerzeichen" gefolgt von "Minuszeichen") erzeugt bzw. überschrieben.

```{r}
x <- 13
y <- 24
```

--

Mit den so erzeugten Variablen können wir natürlich auch rechnen.

```{r}
x - y
```

---
## Grundlagen
### Achtung &mdash; Häufiger Fehler:

</br>

Vergessen von `*`, wenn eine Variable mit einem Skalar multipliziert werden soll. 

```{r}
# Richtig:
3 * x 
```

```{r, eval = F}
# Falsch:
3x
```

--

**Problem:**

`r r_black` interpretiert `3x` als Variable, jedoch dürfen Variablennamen nicht mit Ziffern beginnen! Wir erhalten eine Fehlermeldung!

---
## Grundlagen
### Kommentare 

</br>

Auf der vorherigen Folie steht im letzten Codesnippet eine kurze Erklärung angeführt von einem <code>#</code>. Dies kennzeichnet einen <a href='https://de.wikipedia.org/wiki/Kommentar_(Programmierung)'>Kommentar</a>: 

--

*Kommentare werden beim Ausführen des Codes nicht berücksichtigt. Wir nutzen Kommentare, um unseren Code (für uns und andere) verständlicher zu machen.*

---
## Grundlagen
### Datentypen

</br>

Neben den Zahlen gibt es in `r r_black` noch weitere Datentypen. Die für uns Wichtigsten (Zahlen eingeschlossen) sind:  

```{r}
a <- 5               # numeric (Zahlen)
class(a)
```

--

```{r}
b <- "R ist toll!"   # character (Schriftzeichen)   
class(b)

```

---
## Grundlagen
### Datentypen

</br>

```{r}
d <- TRUE            # logical (TRUE / FALSE)
class(d)
```

<br></br>

--

**Häufiger Fehler:** 

Vergessen von Anführungszeichen bei Schriftzeichen und Kleinschreiben von `TRUE` oder `FALSE`.  

---
## Vektoren 
### Erzeugen eines Vektors

Bisher haben wir nur Variablen betrachtet, die einen einzigen Wert enthalten. 
Die große Stärke von `r r_black` sind vektor- und matrixbasierte Funktionen. 

Ein Vektor wird gewöhnlich mit der Funktion `c()` (für **c**ombine) erzeugt und besteht aus einem oder mehreren Elementen **eines** Datentyps. 

--

```{r}
numeric_v   <- c(1, 4, 8)

character_v <- c("Pommes", "Falafel", "Ketchup")

logical_v   <- c(TRUE, FALSE, FALSE)

# oder kürzer `T` für `TRUE` und `F` für `FALSE`
logical_v   <- c(T, F, F)
```

--

**Achtung:** `T` und `F` sollten nicht als Variablen verwendet werden (warum?). 

---
## Vektoren 
### Erzeugen eines Vektors

</br>

Insbesondere für numerische Vektoren gibt es ein paar hilfreiche Shortcuts:
Jede der folgenden Zeilen liefert denselben Output. 

--

```{r}
c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
1:10
seq(from = 1, to = 10, by = 1)
```

---
## Vektoren 
### *Missing Values*

</br>

Bei "echten" Daten kommt es häufig vor, dass es zu einigen Beobachtungen keine Daten für manche Variablen gibt. 

--

**Praxisbeispiel**

Angenommen in einer Umfrage werden die Variablen *Alter*, *Geschlecht* und *Körpergröße* erhoben. 

Problem: Eine Person hat keine Angabe zur Körpergröße gemacht.

--

- In `r r_black` kann der fehlende Wert speziell codiert werden: Anstelle von einer $-99$ oder $0$ (sieht man oft in echten Datensätzen) wird für den fehlenden Wert ein `NA` eingesetzt. 

- Für viele Funktionen kann das Vorgehen bei *Missing Values* festlegt werden (siehe auch _Übungsaufgabe 5_).   

---
## Vektoren 
### *Missing Values*

</br>

Beim Programmieren werden i.d.R. englische Namen verwendet. Meist sind diese kürzer und man vermeidet Probleme aufgrund von Umlauten. 

--

```{r}
age    <- c(25, 28, 29)    

sex    <- c("m", "f", "m") 

height <- c(184, 165, NA)  
```

---
## Vektoren
### Subsetting von Vektoren 

</br>

Um eine Teilmenge der Elemente eines Vektors anzusprechen (*Subsetting* genannt), nutzen wir in eckigen Klammern eingeschlossene *Indizes*.

--

```{r}
numeric_v[2]         # Gibt das 2. Element von numeric_v aus
```

--

```{r}
character_v[c(1, 3)] # Gibt das 1. und 3. Element von character_v aus
```

--

```{r}
logical_v[1:2]       # Gibt das 1. und 2. Element von logical_v aus
```


---
## Vektoren
### Subsetting von Vektoren 

**Häufiger Fehler:** Vergessen von `c()` im 2. Fall. Mehrere Indizes müssen als *Vektor* übergeben werden. 

--

Wir können auch logische Vektoren für das Subsetting nutzen. Diese müssen dieselbe Länge haben wie der Vektor der "gesubsetted" werden soll. Es werden die Elemente ausgegeben, an deren Stellen der logische Vektor den Wert <code>TRUE</code> hat. 

--

```{r}
x  <- c(7, 2, 5, 3, 9)

# Elemente 2 und 5 sollen angesprochen werden
hv <- c(F, T, F, F, T) 

x[hv]
```

--

Das ist hilfreich, da viele Funktionen einen logischen Vektor zurückgeben (z. B. `is.na()` und logische Operatoren, später mehr dazu). 

---
## Vektoren
### Ändern von Elementen 

Manchmal müssen Elemente eines Vektors *geändert* werden. Dazu nutzen wir Subsetting zusammen mit dem Zuweisungsoperator. 

--

**Beispiel**: Ändere das dritte Element des Vektors `x <- c(7, 2, 5, 3, 9)`

```{r}
x    <- c(7, 2, 5, 3, 9)
x[3] <- 49
```

--
Wenn wir mehrere Elemente ändern wollen: 

```{r}
x[c(1, 5)] <- c(25, 14) 
x[c(2, 4)] <- -1        # Setzt das 2. und das 4. Element gleich -1         
```

--

Wie sieht der erzeugte Vektor aus?  

---
## Vektoren
### Vektorbasierte Funktionen 

</br>

Wir betrachten nun den Vektor `age`. Dieser enthält das Alter von 5 Studierenden in diesem Kurs.

```{r}
age <- c(24, 25, 29, 23, 26)
```

--

Wie können wir das Durchschnittsalter berechnen?


---
## Vektoren
### Vektorbasierte Funktionen 

</br>

**Antwort:**

```{r}
age_sum <- age[1] + age[2] + age[3] + age[4] + age[5]
age_sum / 5
```

--

Dieses Vorgehen ist für kleine Vektoren machbar, aber umständlich. Für große Vektoren ist es sehr nervig und nicht mit zeitlichen Restriktionen vereinbar! 

---
## Vektoren
### Vektorbasierte Funktionen 

</br>

Bessere Alternative: *Vordefinierte Funktionen nutzen*:

--

```{r}
# Mittelwert berechnen
age_sum <- sum(age)
age_sum / length(age)
```

--

Oder noch einfacher:

```{r}
mean(age)
```


---
## Vektoren
### I Need Help

Damit haben wir schon einige `r r_black`-Funktionen kennengelernt. Oft ist unklar, wie diese Funktionen funktionieren.

--

$\Rightarrow$ `r r_black`-Hilfe nutzen: 

Angenommen wir sind nicht sicher, was `mean()` genau berechnet oder wie die Funktion aufgerufen werden muss. 

--

```{r, eval = FALSE}
?mean
```

--

Die `r r_black`-Hilfe ist insb. für Anfänger manchmal schwer zu verstehen... 

Nicht verzweifeln, sondern einfach ein bisschen rumprobieren oder eine Suchmaschine bemühen! 

--

**Zwei extrem wichtige Fähigkeiten beim Programmieren, die gleich schon mal geübt werden können!** 

---
## Vektoren
### Vektorbasierte Funktionen &mdash; Eine kleine Übersicht

```{r, results = 'hide'}
x <- c(5, 2, 1055, 101:200)

length(x)       # Länge von x

sum(x)          # Summe der Elemente von x

mean(x)         # Arithmetisches Mittel der Elemente von x

min(x)          # kleinstes Element

max(x)          # größtes Element

which.min(x)    # Index des kleinsten Elements

which.max(x)    # Index des größten Elements

prod(x)         # Produkt aller Elemente

seq_along(x)    # Vektor mit Indizes der Elemente von x
```

---
class: exercise_slide
## Vektoren
### Übungsaufgaben zu Vektoren 

1. Erzeugen Sie einen Vektor `numbers` mit den Elementen $\begin{pmatrix} 4, & 6, & -3, & 2.5, & 18, & \pi, &  85 \end{pmatrix}$.

    *Hinweis:* Die Zahl $\pi$ ist in `r r_black` bereits als `pi` vordefiniert.

2. Berechnen Sie das arithmetische und das harmonische Mittel von `numbers`. 

    *Hinweis:* Für einen numerischen Vektor $X$ der Länge $n$ ist das arithmetische Mittel $\overline{X} = \frac{1}{n} \sum_{i=1}^n X_i$ und das harmonische Mittel $\overline{X}_{harm} = \frac{n}{\sum_{i=1}^n 1/X_i}$.

3. Sie kommen zu dem Schluss, dass die höchste und die niedrigste Zahl die Schätzung verzerren und entscheiden darum, diese Werte zu ignorieren. Ersetzen Sie beide Werte durch `NA` und berechnen Sie die Mittelwerte aus Aufgabe 2 erneut.

---
class: exercise_slide
## Vektoren
### Übungsaufgaben zu Vektoren 

</br>

<ol start="4">
    <li>Nutzen Sie die Funktion <code>seq()</code> um die Folge \(\begin{pmatrix} 0, 0.5, 1, 1.5, \ldots, 99, 99.5, 100 \end{pmatrix}\) zu erzeugen. Wie viele Elemente besitzt dieser Vektor? Überprüfen Sie Ihre Vermutung mit <code>length()</code>.</li>
    <li>Erzeugen Sie einen neuen Vektor <code>characters</code> mit den Elementen \(\begin{pmatrix} a, & a, & a, & b, & b, & b, & b, & c, & c \\ \end{pmatrix}\).  Finden Sie dazu heraus wie die Funktion <code>rep()</code> funktioniert und nutzen Sie diese.</li>
    <li>Überschreiben Sie jetzt den Vektor <code>characters</code> mit \(\begin{pmatrix} x, & y, & z, & x, & y, & z, & x, & y, & z \\ \end{pmatrix}\). Nutzen Sie wieder die Funktion <code>rep()</code>.</li>
    <li>Ersetzen Sie nun alle Elemente mit dem Inhalt  \(z\) durch \(v\).</li>
</ol>

---
class: exercise_slide
## Vektoren
### Übungsaufgaben zu Vektoren 

</br>

<ol start="8">
    <li> Kopieren Sie folgenden Code in Ihr <code>R</code>-Skript</li>
</ol>


  ```{r}
  a <- c(2, 5, 7, 5, 12, 6)
  b <- c(1, 2, 3, 4, 5, 6)
  x <- c(1:2)
  y <- 3
  z <- c(1, 2, 3, 4)
  ```   
Berechnen Sie nun \(a + b\),  \( a + x\),  \( a + y \) und \(a + z\). Finden Sie heraus, wie `r r_black` jeweils vorgeht und schreiben Sie einen kurzen Kommentar.


<ol start="9">
    <li>Erzeugen Sie einen Vektor mit den Elementen \(\begin{pmatrix} 1, & 2, & 3, & a, & b, \\ \end{pmatrix}\). Was passiert? Schreiben Sie einen Kommentar.</li>
</ol>

---
## Matrizen
### Matrizen erzeugen

</br>

Wir können mehrere Vektoren des gleichen Datentyps und gleicher Länge zu einer Matrix zusammenfassen. 

--

```{r}
x <- 1:3
y <- 4:6

xy <- cbind(x, y)
xy
```

---
## Matrizen
### Matrizen erzeugen

</br>

Außerdem können wir auch einen einzelnen Vektor in Matrixform bringen. 

--

```{r}
matrix(1:6, ncol = 2)
```

---
## Matrizen
### Matrixsubsetting 

</br>

Um ein einzelnes Element einer Matrix anzusprechen, müssen wir **zwei** Indizes verwenden: einen für die *Zeile* und einen für die *Spalte* des gewünschten Elements. 

Das folgende Beispiel zeigt, wie man das Element in der 3. Zeile und der 2. Spalte erhält. 

--

```{r}
X <- matrix(1:6, ncol = 2)
X[3, 2]
```

---
## Matrizen
### Matrixsubsetting 

</br>

Um dieses Element zu ändern, nutzen wir wieder den Zuweisungsoperator `<-`.

--

```{r}
X[3, 2] <- 13
X
```

---
## Matrizen
### Matrixsubsetting 

<br>

Um ganze Spalten einer Matrix zu erhalten, wird der Index für die *Zeile* freigelassen.  
```{r}
X[, 1] # gibt die 1. Spalte zurück
```

--

Um ganze Zeilen zu erhalten, wird der Index für die *Spalte* freigelassen. 

```{r}
X[2:3, ] # gibt die 2. und 3. Zeile zurück
```

---
## Matrizen
### Matrixalgebra &mdash; Übersicht 

</br>

```{r, results = 'hide'}
A <- cbind(c(13, 4, 8), c(2, 8.2, 1))
B <- cbind(c(9, 2.3, -1), c(12, 53, -3))

A * B             # Elementweise Multiplikation 

C <- t(A) %*% B   # Matrixmultiplikation

t(A)              # Transponieren

diag(C)           # Elemente der Hauptdiagonale

solve(C)          # Invertieren

eigen(C)          # Eigenwerte und Eigenvektoren
```

---
## Matrizen
### Matrixbasierte Funktionen 

</br>

Wie bei Vektoren gibt es auch eine Reihe von Funktionen für Matrizen. 

```{r, results='hide'}
X <- matrix(1:40, ncol = 4)

colSums(X)   # Spaltensummen

rowSums(X)   # Zeilenensummen

colMeans(X)  # Spaltenmittelwerte

rowMeans(X)  # Zeilenmittelwerte
```

---
class: exercise_slide
## Matrizen
### Übungsaufgaben zu Matrizen 

</br>

1. Erzeugen Sie mit dem Inputvektor `1:12` und <code>matrix()</code> folgende Matrix <code>X</code>. 

$$X =\begin{pmatrix} 
    1 & 2 \\ 
    3 & 4 \\
    5 & 6 \\
    7 & 8 \\
    9 & 10 \\
    11 & 12
  \end{pmatrix}$$

<ol start="2">
    <li>Nehmen Sie die Matrix aus 2.1 und vertauschen Sie die Spalten. Das Ergebnis soll an die Variable \(Y\) übergeben werden. </li>
    <li>Berechnen Sie \(XY^{T}\).</li>
</ol>
 

---
class: exercise_slide
## Matrizen
### Übungsaufgaben zu Matrizen 

</br>

<ol start="4">
    <li>Erzeugen Sie eine \(2 \times 2\) Matrix aus der 2. und 5. Zeile der Matrix <code>X</code>.</li>
    <li>Erzeugen Sie die Matrix <code>X</code> mit <code>X <- matrix(8:-7, nrow = 4)</code>.</li>
    <ul>
    <li>Ersetzen Sie die Elemente auf der Hauptdiagonalen durch <code>NA</code>s.</li>
    <li>Ersetzen Sie jetzt alle <code>NA</code>s in der Matrix durch <code>1</code>.  Nutzen Sie dazu die Funktion <code>is.na()</code>.</li>
    </ul>
</ol>

<!--
.blue[color]
-->


  
